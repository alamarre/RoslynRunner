@page "/"
@rendermode InteractiveServer
@inject IRunQueue runQueue
@inject ICancellationTokenManager cancellationTokenManager
@inject IRunHistoryService runHistoryService
@using System.Text.Json
@using RoslynRunner.Data
@inject IJSRuntime runtime

<MudContainer MaxWidth="MaxWidth.Large">
    <MudTabs Elevation="2" Rounded="true" ApplyEffectsToContainer="true" PanelClass="pa-6">
        <MudTabPanel Text="Run">
            <MudItem>
                <label for="commandType">@Labels.CommandType</label>
                <select name="commandType" @bind="commandType">
                    <option>Analyzer</option>
                    <option>Custom Processor</option>
                </select>
            </MudItem>


            <MudItem>
                <MudTextField @bind-Value="primarySolution" Label=@Labels.PrimarySolution Variant="Variant.Outlined" />
            </MudItem>
            <MudItem>
                <MudCheckBox @bind-Value="persistSolution" Label=@Labels.PersistSolution />
            </MudItem>
            <MudItem>
                <MudTextField @bind-Value="assemblyLoadContextPath" Label=@Labels.AssemblyLoadContextPath
                    Variant="Variant.Outlined" />
            </MudItem>
            @if (commandType == "Analyzer")
            {
                <MudItem>
                    <MudTextField @bind-Value="analyzerProject" Label=@Labels.AnalyzerProjectPath
                        Variant="Variant.Outlined" />
                </MudItem>
                <MudItem>
                    <MudTextField @bind-Value="targetProject" Label=@Labels.TargetProjectName Variant="Variant.Outlined" />
                </MudItem>
                <MudItem>
                    <MudTextField @bind-Value="analyzerNames" Label=@Labels.AnalyzerNames Variant="Variant.Outlined" />
                </MudItem>
            }
            else if (commandType == "Custom Processor")
            {
                <div id="customProcessorFields">
                    <MudItem>
                        <MudTextField @bind-Value="processorSolution" Label=@Labels.ProcessorSolution
                            Variant="Variant.Outlined" />
                    </MudItem>
                    <MudItem>
                        <MudTextField @bind-Value="processorName" Label=@Labels.ProcessorName Variant="Variant.Outlined" />
                    </MudItem>
                    <MudItem>
                        <MudTextField @bind-Value="processorProjectName" Label=@Labels.ProcessorProjectName
                            Variant="Variant.Outlined" />
                    </MudItem>

                    <MudItem>
                        <MudTextField Lines="3" @bind-Value="contextText" Label=@Labels.ContextJson
                            Variant="Variant.Outlined" AutoGrow />
                        @if (contextError != null)
                        {
                            <MudAlert Severity="Severity.Error">@contextError</MudAlert>
                        }
                    </MudItem>
                </div>
            }
            <MudItem>
                <MudButton OnClick="SubmitForm" Color="Color.Primary">Submit</MudButton>
            </MudItem>
        </MudTabPanel>
        <MudTabPanel OnClick="UpdateCommandText" Text="JSON">
            <MudItem>
                <MudTextField Lines="6" Value="@currentRunCommandJson" Label=@Labels.CurrentRunCommandJson
                    ReadOnly="true" Variant="Variant.Outlined" AutoGrow />
                <MudButton OnClick="CopyToClipboard" Variant="Variant.Filled">Copy to Clipboard</MudButton>
            </MudItem>
            <MudItem>
                <MudTextField Lines="6" @bind-Value="loadJsonText" Label=@Labels.LoadJson Variant="Variant.Outlined"
                    AutoGrow />
                <MudButton OnClick="LoadFromJson" Variant="Variant.Filled">Load</MudButton>
            </MudItem>
        </MudTabPanel>
        <MudTabPanel Text="History">
            <MudTabs Rounded="true" ApplyEffectsToContainer="true" PanelClass="pa-4">
                <MudTabPanel Text="Recent Runs">
                    <MudItem Class="mb-4">
                        <MudButton Variant="Variant.Outlined" OnClick="LoadHistoryAsync">Refresh</MudButton>
                    </MudItem>
                    @if (recentRuns.Count == 0)
                    {
                        <MudText Typo="Typo.body1">No runs recorded yet.</MudText>
                    }
                    else
                    {
                        <MudExpansionPanels>
                            @foreach (var run in recentRuns)
                            {
                                <MudExpansionPanel Text="@($"{(run.Succeeded ? "Success" : "Failed")} - {run.CreatedAt.ToLocalTime():g}")">
                                    <MudStack Row="true" Spacing="1" Class="mb-2">
                                        <MudButton OnClick="@(() => RunExistingCommand(run.RunCommand))" Color="Color.Primary" Variant="Variant.Text">Run Again</MudButton>
                                        <MudButton OnClick="@(() => LoadFromRunCommand(run.RunCommand))" Variant="Variant.Text">Load Into Form</MudButton>
                                    </MudStack>
                                    <MudText Typo="Typo.subtitle2">Run Id: @run.RunId</MudText>
                                    <MudText Typo="Typo.subtitle2" Class="mt-2">Command</MudText>
                                    <MudPaper Class="pa-2 mb-2" Elevation="1">
                                        <pre>@JsonSerializer.Serialize(run.RunCommand, prettyJsonOptions)</pre>
                                    </MudPaper>
                                    <MudText Typo="Typo.subtitle2">Output</MudText>
                                    @if (run.Output.Count == 0)
                                    {
                                        <MudText Typo="Typo.body2">(no output)</MudText>
                                    }
                                    else
                                    {
                                        <MudList T="string" Dense="true">
                                            @foreach (var line in run.Output)
                                            {
                                                <MudListItem T="string">@line</MudListItem>
                                            }
                                        </MudList>
                                    }
                                    <MudText Typo="Typo.subtitle2" Class="mt-2">Errors</MudText>
                                    @if (run.Errors.Count == 0)
                                    {
                                        <MudText Typo="Typo.body2">(no errors)</MudText>
                                    }
                                    else
                                    {
                                        <MudList T="string" Dense="true">
                                            @foreach (var error in run.Errors)
                                            {
                                                <MudListItem T="string">@error</MudListItem>
                                            }
                                        </MudList>
                                    }
                                </MudExpansionPanel>
                            }
                        </MudExpansionPanels>
                    }
                </MudTabPanel>
                <MudTabPanel Text="Saved Runs">
                    <MudItem Class="mb-4">
                        <MudStack Row="true" Spacing="2" AlignItems="AlignItems.Center">
                            <MudTextField @bind-Value="newSavedRunName" Label="Saved Run Name" Variant="Variant.Outlined" />
                            <MudButton OnClick="CreateSavedRunFromCurrent" Color="Color.Primary">Save Current Run</MudButton>
                            <MudButton Variant="Variant.Outlined" OnClick="LoadHistoryAsync">Refresh</MudButton>
                        </MudStack>
                    </MudItem>
                    @if (!string.IsNullOrEmpty(saveRunError))
                    {
                        <MudAlert Severity="Severity.Error">@saveRunError</MudAlert>
                    }
                    @if (savedRuns.Count == 0)
                    {
                        <MudText Typo="Typo.body1">No saved runs yet.</MudText>
                    }
                    else
                    {
                        @foreach (var saved in savedRuns)
                        {
                            <MudPaper Class="pa-4 mb-3" Elevation="1">
                                <MudStack Row="true" Justify="Justify.SpaceBetween" AlignItems="AlignItems.Center">
                                    <MudStack>
                                        <MudText Typo="Typo.subtitle1">@saved.Name</MudText>
                                        <MudText Typo="Typo.caption">Saved @saved.CreatedAt.ToLocalTime():g</MudText>
                                    </MudStack>
                                    <MudStack Row="true" Spacing="1">
                                        <MudButton OnClick="@(() => RunSavedRun(saved))" Color="Color.Primary" Variant="Variant.Filled">Run</MudButton>
                                        <MudButton OnClick="@(() => LoadSavedRun(saved))" Variant="Variant.Text">Load</MudButton>
                                        <MudButton OnClick="@(() => DeleteSavedRun(saved.Name))" Color="Color.Error" Variant="Variant.Outlined">Delete</MudButton>
                                    </MudStack>
                                </MudStack>
                            </MudPaper>
                        }
                    }
                </MudTabPanel>
            </MudTabs>
        </MudTabPanel>
    </MudTabs>
</MudContainer>

@code {
    private static readonly JsonSerializerOptions prettyJsonOptions = new() { WriteIndented = true };
    private static readonly JsonSerializerOptions caseInsensitiveOptions = new() { PropertyNameCaseInsensitive = true };

    private string commandType = "Analyzer";
    private string primarySolution = string.Empty;
    public bool persistSolution = false;
    private string? processorSolution = null;
    private string processorName = string.Empty;
    private string? processorProjectName = null;
    private string? assemblyLoadContextPath = null;
    private string analyzerProject = string.Empty;
    private string targetProject = string.Empty;
    private string analyzerNames = string.Empty;
    private string? contextText = null;
    private string? contextError = null;
    private string currentRunCommandJson = string.Empty;
    private string loadJsonText = string.Empty;
    private List<RunHistoryItem> recentRuns = new();
    private List<SavedRunItem> savedRuns = new();
    private string? newSavedRunName;
    private string? saveRunError;

    protected override async Task OnInitializedAsync()
    {
        await LoadHistoryAsync();
    }

    private async Task LoadHistoryAsync()
    {
        var recent = await runHistoryService.GetRecentRunsAsync();
        recentRuns = recent.ToList();
        var saved = await runHistoryService.GetSavedRunsAsync();
        savedRuns = saved.ToList();
        StateHasChanged();
    }

    private async Task CopyToClipboard()
    {
        await runtime.InvokeVoidAsync("copyTextToClipboard", currentRunCommandJson);
    }

    private void UpdateCommandText()
    {
        var runCommand = GetRunCommand();

        currentRunCommandJson = JsonSerializer.Serialize(runCommand, prettyJsonOptions);
        StateHasChanged();
    }

    private RunCommand GetRunCommand()
    {
        RunCommand runCommand;

        if (commandType == "Analyzer")
        {
            var analyzerContext = new
            {
                AnalyzerProject = analyzerProject,
                TargetProject = targetProject,
                AnalyzerNames = analyzerNames?.Split(",").Select(a => a.Trim()).Where(a => !string.IsNullOrWhiteSpace(a)) ?? Array.Empty<string>()
            };
            var serializedContext = JsonSerializer.Serialize(analyzerContext);

            runCommand = new RunCommand(
                primarySolution,
                persistSolution,
                null,
                "AnalyzerRunner",
                null,
                assemblyLoadContextPath,
                Context: serializedContext
            );
        }
        else
        {
            runCommand = new RunCommand(
                primarySolution,
                persistSolution,
                processorSolution,
                processorName,
                processorProjectName,
                assemblyLoadContextPath,
                Context: contextText
            );
        }

        return runCommand;
    }

    private void LoadFromJson()
    {
        try
        {
            var loadedCommand = JsonSerializer.Deserialize<RunCommand>(loadJsonText, caseInsensitiveOptions);

            if (loadedCommand is not null)
            {
                ApplyRunCommand(loadedCommand);
            }
        }
        catch (JsonException)
        {
            contextError = "Invalid JSON input for loading.";
            StateHasChanged();
        }
    }

    private void ApplyRunCommand(RunCommand loadedCommand)
    {
        primarySolution = loadedCommand.PrimarySolution;
        persistSolution = loadedCommand.PersistSolution;
        processorSolution = loadedCommand.ProcessorSolution;
        processorName = loadedCommand.ProcessorName;
        processorProjectName = loadedCommand.ProcessorProjectName;
        assemblyLoadContextPath = loadedCommand.AssemblyLoadContextPath;
        contextText = loadedCommand.Context;

        if (loadedCommand.ProcessorName == "AnalyzerRunner")
        {
            commandType = "Analyzer";
            try
            {
                var analyzerContext = JsonSerializer.Deserialize<AnalyzerContextModel>(loadedCommand.Context ?? "{}", caseInsensitiveOptions);
                analyzerProject = analyzerContext?.AnalyzerProject ?? string.Empty;
                targetProject = analyzerContext?.TargetProject ?? string.Empty;
                analyzerNames = analyzerContext?.AnalyzerNames is not null
                    ? string.Join(",", analyzerContext.AnalyzerNames)
                    : string.Empty;
            }
            catch
            {
                analyzerProject = string.Empty;
                targetProject = string.Empty;
                analyzerNames = string.Empty;
            }
        }
        else
        {
            commandType = "Custom Processor";
        }

        contextError = null;
        UpdateCommandText();
    }

    private async Task SubmitForm()
    {
        var runCommand = GetRunCommand();
        await runQueue.Enqueue(runCommand);
    }

    private async Task RunExistingCommand(RunCommand runCommand)
    {
        await runQueue.Enqueue(runCommand);
    }

    private async Task CreateSavedRunFromCurrent()
    {
        saveRunError = null;

        if (string.IsNullOrWhiteSpace(newSavedRunName))
        {
            saveRunError = "Saved run name is required.";
            return;
        }

        try
        {
            var runCommand = GetRunCommand();
            await runHistoryService.SaveRunAsync(newSavedRunName, runCommand);
            newSavedRunName = string.Empty;
            await LoadHistoryAsync();
        }
        catch (Exception ex)
        {
            saveRunError = $"Failed to save run: {ex.Message}";
        }
    }

    private async Task RunSavedRun(SavedRunItem savedRun)
    {
        await runQueue.Enqueue(savedRun.RunCommand);
    }

    private void LoadSavedRun(SavedRunItem savedRun)
    {
        ApplyRunCommand(savedRun.RunCommand);
    }

    private async Task DeleteSavedRun(string name)
    {
        await runHistoryService.DeleteSavedRunAsync(name);
        await LoadHistoryAsync();
    }

    private void LoadFromRunCommand(RunCommand command)
    {
        ApplyRunCommand(command);
    }

    private class AnalyzerContextModel
    {
        public string? AnalyzerProject { get; set; }
        public string? TargetProject { get; set; }
        public IEnumerable<string>? AnalyzerNames { get; set; }
    }

    public class Labels
    {
        public const string CommandType = "Command Type:";
        public const string PrimarySolution = "Primary Solution";
        public const string PersistSolution = "Persist Solution";
        public const string AssemblyLoadContextPath = "Assembly Load Context Path";
        public const string AnalyzerProjectPath = "Analyzer Project Path";
        public const string TargetProjectName = "Target Project Name";
        public const string AnalyzerNames = "Analyzer Names";
        public const string ProcessorSolution = "Processor Solution";
        public const string ProcessorName = "Processor Name";
        public const string ProcessorProjectName = "Processor Project Name";
        public const string ContextJson = "Context (JSON)";
        public const string CurrentRunCommandJson = "Current Run Command JSON";
        public const string LoadJson = "Load JSON";
    }
}
