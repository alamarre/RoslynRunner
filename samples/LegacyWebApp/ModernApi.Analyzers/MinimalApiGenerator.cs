using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace ModernApi.Analyzers;

public enum HttpVerb
{
    Get,
    Post,
    Put,
    Delete,
    Patch,
    Options,
    Head
}

[Generator]
public class MinimalApiGenerator : IIncrementalGenerator
{
    const string _endpointAttributeName = "ModernWebApi.Endpoints.ApiAttribute";
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        IncrementalValuesProvider<MethodDeclarationSyntax> syntaxProvider = context.SyntaxProvider.CreateSyntaxProvider(
            static (syntaxNode, ct) =>
            {
                if (syntaxNode is not MethodDeclarationSyntax methodDeclarationSyntax)
                {
                    return false;
                }

                return methodDeclarationSyntax.AttributeLists.Any(al =>
                    al.Attributes.Any(a => a.Name.ToString().EndsWith("Api")));
            },
            static (context, ct) => (MethodDeclarationSyntax)context.Node 
        );
        
        IncrementalValueProvider<(Compilation, ImmutableArray<MethodDeclarationSyntax>)> compilationAndNodes
            = context.CompilationProvider.Combine(syntaxProvider.Collect());

        context.RegisterSourceOutput(compilationAndNodes, (ctx, components ) =>
        {
            var (compilation, methods) = components;
            List<IMethodSymbol> methodSymbols = new List<IMethodSymbol>();
            foreach (var method in methods)
            {
                var model = compilation.GetSemanticModel(method.SyntaxTree);
                var methodSymbol = (IMethodSymbol)model.GetDeclaredSymbol(method)!;
                methodSymbols.Add(methodSymbol);
            }

            SymbolDisplayFormat format = SymbolDisplayFormat.FullyQualifiedFormat;
            var grouped = methodSymbols.GroupBy(m => m.ContainingSymbol, SymbolEqualityComparer.Default);
           
            string registrationBody = string.Join("\n         ", grouped.Select(g => 
                @$"services.AddSingleton<global::ModernWebApi.Endpoints.IEndpointMapper, {g!.Key!.ToDisplayString(format)}>();"));

            StringBuilder sb = new StringBuilder();
            foreach (var group in grouped)
            {
                
                sb.AppendLine($"namespace {group.Key.ContainingNamespace.ToDisplayString()} {{");
                sb.AppendLine($"    public partial class {group.Key.Name.ToString()} : global::ModernWebApi.Endpoints.IEndpointMapper  {{");
                sb.AppendLine("        public void MapEndpoints(IEndpointRouteBuilder builder) {");
                foreach (var method in group)
                {
                    var attribute = method.GetAttributes().FirstOrDefault(m => m.AttributeClass!.ToString() == _endpointAttributeName);
                    if (attribute == null)
                    {
                        continue;
                    }
                    var verbInfo = (HttpVerb)attribute.ConstructorArguments[0].Value!;
                    // this is a very lazy way to do it
                    var verb = verbInfo.ToString();
                    sb.AppendLine($"            builder.Map{verb}(\"{attribute.ConstructorArguments[1].Value!.ToString()}\", {method.Name});");
                }
                sb.AppendLine("        }");
                sb.AppendLine("    }");
                sb.AppendLine("}");
            }

            string result = $@"
// <auto-generated />
namespace ModernWebApi.Endpoints {{

public partial class AutomaticEndpoints {{
    partial void _RegisterEndpointMappers(IServiceCollection services) {{
        {registrationBody}
    }}

}}
}}
{sb.ToString()}
                ";
            ctx.AddSource("AutoEndpoints.g.cs", SourceText.From(result, Encoding.UTF8));
            
        });

    }
}
